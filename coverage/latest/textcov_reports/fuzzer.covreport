LLVMFuzzerTestOneInput:
    8|      6|extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    9|      6|  string s( reinterpret_cast<char const*>(data), size ) ;
   10|      6|    auto v = from_json(s);
   11|      6|    if (v != nullptr) {
  ------------------
  |  Branch (11:9): [True: 0, False: 6]
  ------------------
   12|      0|        if (to_json(std::move(v)) != s)
  ------------------
  |  Branch (12:13): [True: 0, False: 0]
  ------------------
   13|      0|            __builtin_trap();
   14|      0|    }
   15|       |
   16|      6|    return 0;
   17|      6|}

_Z9from_jsonRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE:
  245|      6|unique_ptr<JsonValue> from_json(const string& str) {
  246|      6|  pcre2_match_context *match_context = pcre2_match_context_create(nullptr);
  247|      6|  pcre2_set_callout(match_context, callout_handler, nullptr);
  248|      6|  stringstream ss;
  249|      6|  ss << "(*NO_AUTO_POSSESS)(*NO_DOTSTAR_ANCHOR)(*NO_START_OPT)"
  250|      6|        "\\A (?&json_val) \\z"
  251|      6|        "(?(DEFINE)"
  252|      6|        "(?<json_val>"
  253|      6|        "\\s*"
  254|      6|        "("
  255|      6|        "    (?&string)"
  256|      6|        "  |"
  257|      6|        "    (?&push_number)"
  258|      6|        "  |"
  259|      6|        "    (?&object)"
  260|      6|        "  |"
  261|      6|        "    (?&array)"
  262|      6|        "  |"
  263|      6|        "  true (?C" << push_true << ")"
  264|      6|        "|"
  265|      6|        "  false (?C" << push_false << ")"
  266|      6|        "|"
  267|      6|        "  null (?C" << push_null << ")"
  268|      6|        ")"
  269|      6|        "\\s*"
  270|      6|        ")"
  271|      6|        "(?<string> "
  272|      6|        "  ("
  273|      6|        "    \""
  274|      6|        "    (?:"
  275|      6|        "      [^\\\\\"]+"
  276|      6|        "    |"
  277|      6|        "      \\ [\"\\\\/bfnrt]"
  278|      6|        "    )*"
  279|      6|        "    \""
  280|      6|        "  )"
  281|      6|        "(?C" << push_string << ")"
  282|      6|        ")"
  283|      6|        "(?<object> \\{ (?C" << create_map << ") ( (?&key) : (?&value) (?C" << push_back_map << ")"
  284|      6|        "( , \\s* (?&key) : (?&value) (?C" << push_back_map << "))* )? \\} )"
  285|      6|        "(?<key> (?&string) )"
  286|      6|        "(?<value> (?&json_val) )"
  287|      6|        "(?<push_number>"
  288|      6|        "  ("
  289|      6|        "    -?"
  290|      6|        "    (?: 0 | [1-9]\\d* )"
  291|      6|        "    (?: \\. \\d+ )?"
  292|      6|        "    (?: [eE] [-+]? \\d+ )?"
  293|      6|        "  )"
  294|      6|        "  (?C" << push_number << ")"
  295|      6|        ")"
  296|      6|        "(?<array> \\[ (?C" << create_array << ") (?: (?&json_val) (?C" << push_back_array << ")"
  297|      6|        "(?: , (?&json_val) (?C" << push_back_array << "))* )? \\] )"
  298|       |
  299|      6|        ")";
  300|       |  // most of the following code is copied from libpcre2's pcre2demo.c
  301|      6|  auto ss_str = ss.str();
  302|      6|  auto pattern = reinterpret_cast<PCRE2_SPTR>(ss_str.c_str());
  303|      6|  auto subject = reinterpret_cast<PCRE2_SPTR>(str.c_str());
  304|      6|  auto subject_length = static_cast<PCRE2_SIZE>(strlen(reinterpret_cast<const char *>(subject)));
  305|       |
  306|      6|  int errornumber;
  307|      6|  PCRE2_SIZE erroroffset;
  308|      6|  pcre2_code *re = pcre2_compile(
  309|      6|      pattern,                      /* the pattern */
  310|      6|      PCRE2_ZERO_TERMINATED,        /* indicates pattern is zero-terminated */
  311|      6|      PCRE2_EXTENDED, &errornumber, /* for error push_number */
  312|      6|      &erroroffset,                 /* for error offset */
  313|      6|      nullptr);                     /* use default compile context */
  314|       |
  315|      6|  if (re == nullptr) {
  ------------------
  |  Branch (315:7): [True: 0, False: 6]
  ------------------
  316|      0|    constexpr int BUF_SZ = 256;
  317|      0|    array<PCRE2_UCHAR, BUF_SZ> buffer {};
  318|      0|    pcre2_get_error_message(errornumber, buffer.data(), buffer.size());
  319|       |    /* cout << "PCRE2 compilation failed at offset " << erroroffset << ": " */
  320|       |    /*      << buffer.data() << endl; */
  321|      0|    return nullptr;
  322|      0|  }
  323|       |
  324|      6|  pcre2_match_data *match_data =
  325|      6|      pcre2_match_data_create_from_pattern(re, nullptr);
  326|       |
  327|      6|  int rc = pcre2_match(re,             /* the compiled pattern */
  328|      6|                       subject,        /* the subject string */
  329|      6|                       subject_length, /* the length of the subject */
  330|      6|                       0,              /* start at offset 0 in the subject */
  331|      6|                       0,              /* default options */
  332|      6|                       match_data,     /* block for storing the result */
  333|      6|                       match_context); /* use default match context */
  334|       |  /* nullptr);       /1* use default match context *1/ */
  335|       |
  336|       |  /* Matching failed: handle error cases */
  337|       |
  338|      6|  if (rc < 0) {
  ------------------
  |  Branch (338:7): [True: 6, False: 0]
  ------------------
  339|      6|    if (rc == PCRE2_ERROR_NOMATCH) {
  ------------------
  |  Branch (339:9): [True: 6, False: 0]
  ------------------
  340|       |        /* cout << "No match" << endl; */
  341|      6|    } else {
  342|       |      /* cout << "Matching error: " << rc << endl; */
  343|      0|    }
  344|      6|    pcre2_match_data_free(match_data); /* Release memory used for the match */
  345|      6|    pcre2_code_free(re);               /*   data and the compiled pattern. */
  346|      6|    pcre2_match_context_free(match_context);
  347|      6|    return nullptr;
  348|      6|  }
  349|       |
  350|       |  /* Match succeded. Get a pointer to the output vector, where string offsets
  351|       |  are stored. */
  352|       |
  353|      0|  PCRE2_SIZE *ovector = pcre2_get_ovector_pointer(match_data);
  354|       |
  355|       |  /*************************************************************************
  356|       |   * We have found the first match within the subject string. If the output *
  357|       |   * vector wasn't big enough, say so. Then output any substrings that were *
  358|       |   * captured.                                                              *
  359|       |   *************************************************************************/
  360|       |
  361|       |  /* The output vector wasn't big enough. This should not happen, because we
  362|       |  used pcre2_match_data_create_from_pattern() above. */
  363|       |
  364|      0|  if (rc == 0) {
  ------------------
  |  Branch (364:7): [True: 0, False: 0]
  ------------------
  365|       |      /* cout << "ovector was not big enough for all the captured substrings" << endl; */
  366|      0|  }
  367|       |
  368|       |  /* We must guard against patterns such as /(?=.\K)/ that use \K in an
  369|       |  assertion to set the start of a match later than its end. In this
  370|       |  demonstration program, we just detect this case and give up. */
  371|       |
  372|      0|  if (ovector[0] > ovector[1]) {
  ------------------
  |  Branch (372:7): [True: 0, False: 0]
  ------------------
  373|       |    /* cout << */
  374|       |    /*     "\\K was used in an assertion to set the match start after its end.\n"; */
  375|       |    /*     /1* "From end to start the match was: %.*s\n", *1/ */
  376|       |    /*     /1* (int)(ovector[0] - ovector[1]), (char *)(subject + ovector[1]); *1/ */
  377|       |    /* cout << "Run abandoned" << endl; */
  378|      0|    pcre2_match_data_free(match_data);
  379|      0|    pcre2_code_free(re);
  380|      0|    pcre2_match_context_free(match_context);
  381|      0|    return nullptr;
  382|      0|  }
  383|      0|  pcre2_match_data_free(match_data);
  384|      0|  pcre2_code_free(re);
  385|      0|  pcre2_match_context_free(match_context);
  386|      0|  return move(st.back());
  387|      0|}
pcre2_ast.cpp:_ZL15callout_handlerP21pcre2_callout_block_8Pv:
  182|      6|static int callout_handler(pcre2_callout_block *c, void *data) {
  183|      6|  if (is_debug) {
  ------------------
  |  Branch (183:7): [Folded - Ignored]
  ------------------
  184|      0|    cout << command_to_string(static_cast<command>(c->callout_number)) << endl;
  185|      0|  }
  186|      6|  switch (c->callout_number) {
  187|      0|  case create_array: {
  ------------------
  |  Branch (187:3): [True: 0, False: 6]
  ------------------
  188|      0|    JsonValue val = vector<unique_ptr<s>> {};
  189|      0|    st.push_back(make_unique<JsonValue>(move(val)));
  190|      0|  } break;
  191|      0|  case push_back_array: {
  ------------------
  |  Branch (191:3): [True: 0, False: 6]
  ------------------
  192|      0|    unique_ptr<JsonValue> x = move(st.back());
  193|      0|    st.pop_back();
  194|      0|    unique_ptr<JsonValue> vec_variant = move(st.back());
  195|      0|    st.pop_back();
  196|      0|    vector<unique_ptr<s>> vec = move(get<vector<unique_ptr<s>>>(*vec_variant));
  197|      0|    vec.push_back(unique_ptr<s>(new s { .v = move(*x) }));
  198|      0|    st.push_back(make_unique<JsonValue>(move(vec)));
  199|      0|  } break;
  200|      6|  case push_number: {
  ------------------
  |  Branch (200:3): [True: 6, False: 0]
  ------------------
  201|      6|    auto begin_offset = c->offset_vector[c->capture_last * 2];
  202|      6|    auto end_offset   = c->offset_vector[c->capture_last * 2 + 1];
  203|      6|    string subject { (char*)c->subject };
  204|      6|    auto val_str = subject.substr(begin_offset, end_offset - begin_offset);
  205|      6|    st.push_back(make_unique<JsonValue>(stod(val_str)));
  206|      6|  } break;
  207|      0|  case push_string: {
  ------------------
  |  Branch (207:3): [True: 0, False: 6]
  ------------------
  208|      0|    auto begin_offset = c->offset_vector[c->capture_last * 2];
  209|      0|    auto end_offset   = c->offset_vector[c->capture_last * 2 + 1];
  210|      0|    string subject { (char*)c->subject };
  211|      0|    JsonValue val_str = parse_json_string(subject.substr(begin_offset, end_offset - begin_offset));
  212|      0|    st.push_back(make_unique<JsonValue>(move(val_str)));
  213|      0|  } break;
  214|      0|  case create_map: {
  ------------------
  |  Branch (214:3): [True: 0, False: 6]
  ------------------
  215|      0|    st.push_back(make_unique<JsonValue>(map<string, unique_ptr<s>> {}));
  216|      0|  } break;
  217|      0|  case push_back_map: {
  ------------------
  |  Branch (217:3): [True: 0, False: 6]
  ------------------
  218|      0|    unique_ptr<JsonValue> v = move(st.back());
  219|      0|    st.pop_back();
  220|      0|    string k = get<string>(*move(st.back()));
  221|      0|    st.pop_back();
  222|      0|    map<string, unique_ptr<s>> m = move(get<map<string, unique_ptr<s>>>(*st.back()));
  223|      0|    st.pop_back();
  224|      0|    m[k] = unique_ptr<s> { new s { .v = move(*v) } };
  225|      0|    st.push_back(make_unique<JsonValue>(move(m)));
  226|      0|  } break;
  227|      0|  case push_true: {
  ------------------
  |  Branch (227:3): [True: 0, False: 6]
  ------------------
  228|      0|      st.push_back(move(make_unique<JsonValue>(true)));
  229|      0|  } break;
  230|      0|  case push_false: {
  ------------------
  |  Branch (230:3): [True: 0, False: 6]
  ------------------
  231|      0|    st.push_back(move(make_unique<JsonValue>(false)));
  232|      0|  } break;
  233|      0|  case push_null: {
  ------------------
  |  Branch (233:3): [True: 0, False: 6]
  ------------------
  234|      0|    st.push_back(move(make_unique<JsonValue>(monostate {})));
  235|      0|  } break;
  236|      0|  default: {
  ------------------
  |  Branch (236:3): [True: 0, False: 6]
  ------------------
  237|      0|    cout << "Exception is exceptional" << endl;
  238|      0|    throw exception{};
  239|      0|  }
  240|      6|  }
  241|      6|  return 0;
  242|      6|}

